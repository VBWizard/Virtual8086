using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;
using System.Collections;
using System.Diagnostics;
using Word = System.UInt16;
using DWord = System.UInt32;
using QWord = System.UInt64;
using System.Runtime.Serialization;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;

namespace VirtualProcessor
{
    [StructLayout(LayoutKind.Explicit)]
    public struct sOpVal
    {
        [FieldOffset(0)]
        public byte OpByte;
        [FieldOffset(0)]
        public UInt16 OpWord;
        [FieldOffset(0)]
        public UInt32 OpDWord;
        [FieldOffset(0)]
        public UInt64 OpQWord;

        public sOpVal(UInt64 Value)
        {
            OpByte = 0;
            OpWord = 0;
            OpDWord = 0;
            OpQWord = Value;
        }
    }

    public class Instruct
    {
        #region Variables & Definitions
        public string mName;
        public string Name { get { return mName; } }
        public string mDescription;
        internal string Description { get { return mDescription; } }
        internal cOpCodeList mOpCodes = new cOpCodeList();
        public bool mFlowNonReturningInstruction;

        internal Processor_80x86 mProc;
        public string Operand1SValue, Operand2SValue, Operand3SValue, CombinedSValue;
        public UInt64 UsageCount = 0;
        public Double TotalTimeInInstruct = 0;
        internal DateTime mLastStart;
        //From the decoder, set by the mProcessor just before calling us to execute
        public sInstruction DecodedInstruction;
        //Ref booleans are set during decoding
        public bool Operand1IsRef, Operand2IsRef, Operand3IsRef, REPAble=false;
        public sOpCode ChosenOpCode;
        #region Valid Processors for instruction
        protected bool mProc8086 = false, mProc8088 = false, mProc80186 = false, mProc80286 = false,
           mProc80386 = false, mProc80486 = false, mProcPentium = false, mProcPentiumPro = false;
        internal bool Proc8086 { get { return mProc8086; } }
        internal bool Proc8088 { get { return mProc8088; } }
        internal bool Proc80186 { get { return mProc80186; } }
        internal bool Proc80286 { get { return mProc80286; } }
        internal bool Proc80386 { get { return mProc80386; } }
        internal bool Proc80486 { get { return mProc80486; } }
        internal bool ProcPentium { get { return mProcPentium; } }
        internal bool ProcPentiumPro { get { return mProcPentiumPro; } }
        #endregion
        protected eFLAGS mModFlags;
        internal eFLAGS FlagsMod { get { return mModFlags; } }
        public TypeCode Op1TypeCode, Op2TypeCode, Op3TypeCode;
        public sOpVal Op1Value, Op2Value, Op3Value;
        public DWord Op1Add, Op2Add, Op3Add;
        internal bool mInternalInstructionCall = false, mOverride1 = false, mOverride2 = false;
        public bool FPUInstruction = false;
        internal bool lOpSize16, lAddrSize16, lSetupOnce, mOverrideAddrSizeFor32BitGate = false;
        /// <summary>
        /// True if the current call to the INT instruction was generated by software, false if hardware or exception generated
        /// </summary>
        internal bool mIntIsSoftware;
        internal bool valid = true;


        #region ResolveOp Variables
        sOpCodeAddressingMethod OcAM = sOpCodeAddressingMethod.None;
        sOpCodeOperandType OcOT = sOpCodeOperandType.None;
        sOperand Operand = new sOperand(); //Don't want to initialize it but the compiler won't let me not init it
        sOperand Op1Operand = new sOperand();
        sOperand Op2Operand = new sOperand();
        sOperand Op3Operand = new sOperand();
        eGeneralRegister ChosenOpCode_Register = eGeneralRegister.NONE;
        bool HasImmediateData = false, OpHasEffective = false;
        bool Op1Populated, Op2Populated, Op3Populated;
        #endregion

        #endregion

        public Instruct() { }

        public void SetupExecution(Processor_80x86 Proc)
        {
            mProc = Proc;
            mIntIsSoftware = true;
            Op1Populated = false;
            Op2Populated = false;
            Op3Populated = false;
            mInternalInstructionCall = false;
            if (!lSetupOnce)
                lOpSize16 = mProc.mCurrInstructOpSize16;

            if (mProc.OperatingMode != ProcessorMode.Protected)
            {   //Real or Virtual-8086
                bool lTempOpSize32 = false;
                bool lTempAddrSize32 = false;

                if (DecodedInstruction.OpSizePrefixFound)
                    lTempOpSize32 = !lTempOpSize32;
                lOpSize16 = !lTempOpSize32;

                if (DecodedInstruction.AddrSizePrefixFound)
                    lTempAddrSize32 = !lTempAddrSize32;
                lAddrSize16 = !lTempAddrSize32;
                //Already Set Once above
                //lOpSize16 = mProc.OpSize16;
                lAddrSize16 = lOpSize16;
            }
            else
            {

                if (mProc.regs.CS.mDescriptorNum != 0)
                {
                    bool lTempOpSize32 = mProc.regs.CS.Selector.granularity.OpSize32;
                    bool lTempAddrSize32 = mProc.regs.CS.Selector.granularity.OpSize32;

                    //                            if (DecodedInstruction.OpSizePrefixFound)
                    //                                lTempOpSize32 = !lTempOpSize32;
                    lOpSize16 = !lTempOpSize32;

                    //                            if (DecodedInstruction.AddrSizePrefixFound)
                    //                                lTempAddrSize32 = !lTempAddrSize32;
                    lAddrSize16 = !lTempAddrSize32;

                }
                else
                {
                    //Already Set Once above
                    //lOpSize16 = mProc.OpSize16;
                    lAddrSize16 = lOpSize16;
                }
            }

            if (ChosenOpCode.Op1AM != sOpCodeAddressingMethod.None)
            {
                ResolveOp2(1, ref Op1Add, ref Op1Value, ref Op1TypeCode, ref Operand1SValue);
                if (!DecodedInstruction.ExceptionThrown && (Op1Add < Processor_80x86.REGADDRBASE) && (mProc.regs.CR0 & 0x80000000) == 0x80000000 && (DecodedInstruction.OpCode != 0x8d) && (!ChosenOpCode.ImmedOp1) && (DecodedInstruction.Op1.Register == eGeneralRegister.NONE))
                {
                    if (mProc.mem.PageAccessWillCausePF(mProc, ref DecodedInstruction, Op1Add, false))
                    {
                        return;
                    }
                }
                else if (DecodedInstruction.ExceptionThrown)
                    return;
                Op1Operand = Operand;
                Op1Populated = true;
            }
            else
            {
                Op1Add = 0;
                Op1Value.OpQWord = 0;
            }
            if (ChosenOpCode.Op2AM != sOpCodeAddressingMethod.None && !DecodedInstruction.ExceptionThrown)
            {
                ResolveOp2(2, ref Op2Add, ref Op2Value, ref Op2TypeCode, ref Operand2SValue);
                if (!DecodedInstruction.ExceptionThrown && (Op2Add < Processor_80x86.REGADDRBASE) && (mProc.regs.CR0 & 0x80000000) == 0x80000000 && (DecodedInstruction.OpCode != 0x8d) && (!ChosenOpCode.ImmedOp2) && (DecodedInstruction.Op2.Register == eGeneralRegister.NONE))
                {
                    if (mProc.mem.PageAccessWillCausePF(mProc, ref DecodedInstruction, Op2Add, false))
                    {
                        return;
                    }
                }
                else if (DecodedInstruction.ExceptionThrown)
                    return;
                Op2Operand = Operand;
                Op2Populated = true;
            }
            else
            {
                Op2Add = 0;
                Op2Value.OpQWord = 0;
            }
            if (ChosenOpCode.Op3AM != sOpCodeAddressingMethod.None && !DecodedInstruction.ExceptionThrown)
            {
                ResolveOp2(3, ref Op3Add, ref Op3Value, ref Op3TypeCode, ref Operand3SValue);
                if (!DecodedInstruction.ExceptionThrown && (Op3Add < Processor_80x86.REGADDRBASE) && (mProc.regs.CR0 & 0x80000000) == 0x80000000 && (DecodedInstruction.OpCode != 0x8d) && (!ChosenOpCode.ImmedOp3) && (DecodedInstruction.Op3.Register == eGeneralRegister.NONE))
                {
                    if (mProc.mem.PageAccessWillCausePF(mProc, ref DecodedInstruction, Op3Add, false))
                    {
                        return;
                    }
                }
                else if (DecodedInstruction.ExceptionThrown)
                    return;
                Op3Operand = Operand;
                Op3Populated = true;
            }
            else
            {
                Op3Add = 0;
                Op3Value.OpQWord = 0;
            }
#if DECODE_MAKE_STRINGS
            if (mProc.mGenerateDecodeStrings)
            {
                CombinedSValue = BuildOpString(1, Op1Operand, Op1Add, Op1Value, Op1TypeCode);
                if (Op2Populated)
                    CombinedSValue += "," + BuildOpString(2, Op2Operand, Op2Add, Op2Value, Op2TypeCode);
                if (Op3Populated)
                    CombinedSValue += "," + BuildOpString(3, Op3Operand, Op3Add, Op3Value, Op3TypeCode);

            }
#endif

            //CombindedSValue
        }

        public override string ToString()
        {
            //return base.ToString();
            SetupExecution(mProc);
            CombinedSValue = BuildOpString(1, Op1Operand, Op1Add, Op1Value, Op1TypeCode);
            if (Op2Populated)
                CombinedSValue += "," + BuildOpString(2, Op2Operand, Op2Add, Op2Value, Op2TypeCode);
            if (Op3Populated)
                CombinedSValue += "," + BuildOpString(3, Op3Operand, Op3Add, Op3Value, Op3TypeCode);
            CombinedSValue = this.Name + "\t" + CombinedSValue;
            return CombinedSValue.ToString();
        }

        protected string BuildOpString(int OpNum, sOperand Operand, DWord OpAdd, sOpVal Val, TypeCode OpTypeCode)
        {
            StringBuilder lRetVal = new StringBuilder();

            switch (OpNum)
            {
                case 1:
                    OcAM = ChosenOpCode.Op1AM;
                    //OcOT = ChosenOpCode.Op1OT;
                    OpHasEffective = DecodedInstruction.Op1.HasEffective;
                    //Operand = DecodedInstruction.Op1;
                    //ChosenOpCode_Register = ChosenOpCode.Register1;
                    HasImmediateData = ChosenOpCode.ImmedOp1;
                    //Operand1IsRef = !HasImmediateData;
                    //if (OcAM == sOpCodeAddressingMethod.OpOffset)
                    //    Operand1IsRef = true;
                    break;
                case 2:
                    OcAM = ChosenOpCode.Op2AM;
                    //OcOT = ChosenOpCode.Op2OT;
                    OpHasEffective = DecodedInstruction.Op2.HasEffective;
                    //Operand = DecodedInstruction.Op2;
                    //ChosenOpCode_Register = ChosenOpCode.Register2;
                    HasImmediateData = ChosenOpCode.ImmedOp2;
                    //Operand2IsRef = !HasImmediateData;
                    //if (OcAM == sOpCodeAddressingMethod.OpOffset)
                    //    Operand2IsRef = true;
                    break;
                case 3:
                    OcAM = ChosenOpCode.Op3AM;
                    //OcOT = ChosenOpCode.Op3OT;
                    OpHasEffective = DecodedInstruction.Op3.HasEffective;
                    //Operand = DecodedInstruction.Op3;
                    //ChosenOpCode_Register = ChosenOpCode.Register3;
                    HasImmediateData = ChosenOpCode.ImmedOp3;
                    //Operand3IsRef = !HasImmediateData;
                    //if (OcAM == sOpCodeAddressingMethod.OpOffset)
                    //    Operand3IsRef = true;
                    break;
            }

            //OpOffset
            if (OcAM == sOpCodeAddressingMethod.OpOffset)
            {
                if (Operand.HasImm16)
                    lRetVal.AppendFormat("[{0}]", OpAdd.ToString("X4"));
                else
                    lRetVal.AppendFormat("[{0}]", OpAdd.ToString("X8"));
            }
            else if (HasImmediateData)
            {
                if (OcAM == sOpCodeAddressingMethod.JmpRelOffset)
                {
                    UInt16 lTemp = (UInt16)DecodedInstruction.InstructionEIP;

                    if (Operand.HasImm8)
                    {
                        byte lTempB = Val.OpByte;
                        if (Misc.IsNegative(lTempB))
                        {
                            lTempB = Misc.Negate(lTempB);
                            lTemp -= lTempB;
                        }
                        else
                            lTemp += lTempB;
                    }
                    else
                        lTemp += Val.OpWord;

                    lTemp += DecodedInstruction.BytesUsed;
                    lRetVal.Append(lTemp.ToString("X4"));
                }
                else
                {
                    if (Operand.HasImm8)
                        lRetVal.Append(Val.OpByte.ToString("X2"));
                    else if (Operand.HasImm16)
                        lRetVal.Append(Val.OpWord.ToString("X4"));
                    else if (Operand.HasImm32)
                        lRetVal.Append(Val.OpDWord.ToString("X8"));
                    else if (Operand.HasImm64)
                        lRetVal.Append(Val.OpQWord.ToString("X16"));
                }
            }
            //Register in operand filled
            else if (Operand.Register != eGeneralRegister.NONE)
            {
                lRetVal.Append(Operand.Register.ToString());
            }

            //OpHasEffective
            else if (OpHasEffective)
            {
                lRetVal.Append("[");
                if (Operand.EffReg1 != eGeneralRegister.NONE)
                    lRetVal.Append(Operand.EffReg1.ToString());
                if (Operand.SIBMultiplier > 0)
                    lRetVal.AppendFormat("*{0}", Operand.SIBMultiplier.ToString("X1"));
                if (Operand.EffReg2 != eGeneralRegister.NONE)
                    lRetVal.AppendFormat("+{0}", Operand.EffReg2.ToString());
                if (Operand.HasDisp8 || Operand.HasDisp16 || Operand.HasDisp32)
                {
                    string lTemp = "";
                    if (lRetVal.Length != 1)
                        lTemp = "+";
                    if (Operand.HasDisp8)
                    {
                        if (Operand.DispIsNegative)
                        {
                            if (lTemp.Length == 0)
                                lRetVal.Append(Operand.Disp8.ToString("X2"));
                            else
                                lRetVal.AppendFormat("-{0}", Operand.Disp8.ToString("X2"));
                        }
                        else
                            lRetVal.Append(lTemp + Operand.Disp8.ToString("X2"));
                    }
                    else if (Operand.HasDisp16)
                        lRetVal.Append(lTemp + Operand.Disp16.ToString("X4"));
                    else if (Operand.HasDisp32)
                        lRetVal.Append(lTemp + Operand.Disp32.ToString("X8"));
                }
                lRetVal.Append("]");
            }

            return lRetVal.ToString();
        }

        protected void ResolveOp2(int OpNum, ref DWord OpAdd, ref sOpVal Val, ref TypeCode OpTypeCode, ref String OpVals)
        {
            HasImmediateData = false;
            OpAdd = 0;
            Val.OpQWord = 0;
            #region Populate variables based on OpNum
            switch (OpNum)
            {
                case 1:
                    OcAM = ChosenOpCode.Op1AM;
                    OcOT = ChosenOpCode.Op1OT;
                    OpHasEffective = DecodedInstruction.Op1.HasEffective;
                    Operand = DecodedInstruction.Op1;
                    ChosenOpCode_Register = ChosenOpCode.Register1;
                    HasImmediateData = ChosenOpCode.ImmedOp1;
                    Operand1IsRef = !HasImmediateData;
                    if (OcAM == sOpCodeAddressingMethod.OpOffset)
                        Operand1IsRef = true;
                    break;
                case 2:
                    OcAM = ChosenOpCode.Op2AM;
                    OcOT = ChosenOpCode.Op2OT;
                    OpHasEffective = DecodedInstruction.Op2.HasEffective;
                    Operand = DecodedInstruction.Op2;
                    ChosenOpCode_Register = ChosenOpCode.Register2;
                    HasImmediateData = ChosenOpCode.ImmedOp2;
                    Operand2IsRef = !HasImmediateData;
                    if (OcAM == sOpCodeAddressingMethod.OpOffset)
                        Operand2IsRef = true;
                    break;
                case 3:
                    OcAM = ChosenOpCode.Op3AM;
                    OcOT = ChosenOpCode.Op3OT;
                    OpHasEffective = DecodedInstruction.Op3.HasEffective;
                    Operand = DecodedInstruction.Op3;
                    ChosenOpCode_Register = ChosenOpCode.Register3;
                    HasImmediateData = ChosenOpCode.ImmedOp3;
                    Operand3IsRef = !HasImmediateData;
                    if (OcAM == sOpCodeAddressingMethod.OpOffset)
                        Operand3IsRef = true;
                    break;
            }
            #endregion
            #region Fix up OpType
            if (OcOT == sOpCodeOperandType.ByteOrWord)
                if (mProc.mCurrInstructOpSize16)
                    OcOT = sOpCodeOperandType.Byte;
                else
                    OcOT = sOpCodeOperandType.Word;
            else if (OcOT == sOpCodeOperandType.WordOrDWord)
                if (mProc.mCurrInstructOpSize16)
                    OcOT = sOpCodeOperandType.Word;
                else
                    OcOT = sOpCodeOperandType.DWord;
            else if (OcOT == sOpCodeOperandType.Pointer)
                if (mProc.mCurrInstructOpSize16)
                    OcOT = sOpCodeOperandType.DWord;
                else
                    OcOT = sOpCodeOperandType.QWord;

            #endregion

            #region OppOffset
            if (OcAM == sOpCodeAddressingMethod.OpOffset)
            {
                if (Operand.HasImm8)
                {
                    OpAdd = Operand.Imm8;
                }
                else if (Operand.HasImm16)
                {
                    OpAdd = Operand.Imm16;
                }
                else if (Operand.HasImm32)
                {
                    OpAdd = Operand.Imm32;
                }
                else
                    throw new Exception("Where's the data?");

                if (DecodedInstruction.OverrideSegment != eGeneralRegister.NONE)
                {
                    if (Processor_80x86.mProtectedModeActive)
                    {
                        OpAdd += mProc.GetDWordRegValueForRegEnum(DecodedInstruction.OverrideSegment);
                    }
                    else
                    {
                        OpAdd += mProc.GetDWordRegValueForRegEnum(DecodedInstruction.OverrideSegment) << 4;
                    }
                }
                else
                {
                    if (Processor_80x86.mProtectedModeActive)
                    {
                        OpAdd += mProc.GetDWordRegValueForRegEnum(eGeneralRegister.DS);
                    }
                    else
                    {
                        OpAdd += mProc.GetDWordRegValueForRegEnum(eGeneralRegister.DS) << 4;
                    }
                }
                #region Get Value for Address by OpType
                if ((mProc.regs.CR0 & 0x80000000) == 0x80000000 && mProc.mem.PageAccessWillCausePF(mProc, ref DecodedInstruction, OpAdd, false))
                {
                    return;
                }
                else
                    switch (OcOT)
                    {
                        case sOpCodeOperandType.Byte: Val.OpByte = mProc.mem.GetByte(mProc, ref DecodedInstruction, OpAdd); OpTypeCode = TypeCode.Byte; break;
                        case sOpCodeOperandType.Word: Val.OpWord = mProc.mem.GetWord(mProc, ref DecodedInstruction, OpAdd); OpTypeCode = TypeCode.UInt16; break;
                        case sOpCodeOperandType.DWord: Val.OpDWord = mProc.mem.GetDWord(mProc, ref DecodedInstruction, OpAdd); OpTypeCode = TypeCode.UInt32; break;
                        case sOpCodeOperandType.QWord: Val.OpQWord = mProc.mem.GetQWord(mProc, ref DecodedInstruction, OpAdd); OpTypeCode = TypeCode.UInt64; break;
                        case sOpCodeOperandType.Pointer:
                        case sOpCodeOperandType.PseudoDesc:
                            Val.OpQWord = mProc.mem.GetQWord(mProc, ref DecodedInstruction, OpAdd) & 0xFFFFFFFFFFFF; OpTypeCode = TypeCode.UInt64; break;
                    }
                #endregion
                return;
            }
            #endregion
            #region HasImmediateData
            else if (HasImmediateData)
            {
                if (Operand.HasImm8)
                {
                    Val.OpByte = Operand.Imm8; OpTypeCode = TypeCode.Byte;
                }
                else if (Operand.HasImm16)
                {
                    Val.OpWord = Operand.Imm16; OpTypeCode = TypeCode.UInt16;
                }
                else if (Operand.HasImm32)
                {
                    Val.OpDWord = Operand.Imm32; OpTypeCode = TypeCode.UInt32;
                }
                else if (Operand.HasImm64)
                {
                    Val.OpQWord = Operand.Imm64; OpTypeCode = TypeCode.UInt64;
                }
                else
                    throw new Exception("ResolveOp: Has immediate data but it isn't filled in!");
                return;
            }
            #endregion
            #region Register in operand filled
            else if (Operand.Register != eGeneralRegister.NONE)
            {
                OpAdd = mProc.GetRegAddrForRegEnum(Operand.Register);
                if ((int)Operand.Register <= 0x08)
                {
                    Val.OpByte = mProc.GetByteRegValueForRegEnum(Operand.Register);
                    OpTypeCode = TypeCode.Byte;
                }
                else if ((int)Operand.Register <= 0x18)
                {
                    Val.OpWord = mProc.GetWordRegValueForRegEnum(Operand.Register);
                    OpTypeCode = TypeCode.UInt16;
                }
                else if ((int)Operand.Register <= 0xF000)
                {
                    Val.OpDWord = mProc.GetDWordRegValueForRegEnum(Operand.Register);
                    OpTypeCode = TypeCode.UInt32;
                }
                else
                    throw new Exception("Huh?");
                //OpAdd = mProc.GetRegAddrForRegEnum(Operand.Register);
                return;
            }
            #endregion
            #region OpHasEffective
            else if (OpHasEffective)
            {
                UInt16 lTempAddr16 = 0;
                UInt32 lTempAddr32 = 0;

                if (Operand.EffReg1 != eGeneralRegister.NONE)
                {
                    if (lAddrSize16)
                    {
                        if ((int)Operand.EffReg1 <= 0x08)
                        {
                            lTempAddr16 += mProc.GetByteRegValueForRegEnum(Operand.EffReg1);
                        }
                        else if ((int)Operand.EffReg1 <= 0x18)
                        {
                            lTempAddr16 += mProc.GetWordRegValueForRegEnum(Operand.EffReg1);
                        }
                        else if ((int)Operand.EffReg1 <= 0xF000)
                        {
                            //Only getting the bottom word of the dword register
                            lTempAddr16 += (Word)mProc.GetDWordRegValueForRegEnum(Operand.EffReg1);
                            //throw new ExceptionNumber("32 big register to 16 bit address?");
                        }
                    }
                    else
                    {
                        if ((int)Operand.EffReg1 <= 0x08)
                        {
                            lTempAddr32 += mProc.GetByteRegValueForRegEnum(Operand.EffReg1);
                        }
                        else if ((int)Operand.EffReg1 <= 0x18)
                        {
                            lTempAddr32 += mProc.GetWordRegValueForRegEnum(Operand.EffReg1);
                        }
                        else if ((int)Operand.EffReg1 <= 0xF000)
                        {
                            lTempAddr32 += mProc.GetDWordRegValueForRegEnum(Operand.EffReg1);
                        }

                    }
                }
                if (Operand.SIBMultiplier > 0)
                {
                    if (lAddrSize16)
                        lTempAddr16 *= (Operand.SIBMultiplier);
                    else
                        lTempAddr32 *= Operand.SIBMultiplier;
                }
                if (Operand.EffReg2 != eGeneralRegister.NONE)
                {
                    if (lAddrSize16)
                        lTempAddr16 += (UInt16)(mProc.GetRegValueForRegEnum(Operand.EffReg2) & 0xFFFF);
                    else
                        lTempAddr32 += mProc.GetRegValueForRegEnum(Operand.EffReg2);
                }
                if (Operand.HasDisp8)
                {
                    if (Operand.DispIsNegative)
                        if (lAddrSize16)
                            lTempAddr16 -= Operand.Disp8;
                        else
                            lTempAddr32 -= Operand.Disp8;
                    else
                        if (lAddrSize16)
                            lTempAddr16 += Operand.Disp8;
                        else
                            lTempAddr32 += Operand.Disp8;
                }
                else if (Operand.HasDisp16)
                    if (lAddrSize16)
                        lTempAddr16 += Operand.Disp16;
                    else
                        lTempAddr32 += Operand.Disp16;
                else if (Operand.HasDisp32)
                    if (lAddrSize16)
                        if (Operand.DispIsNegative)
                            lTempAddr16 -= (Word)Operand.Disp32;
                        else
                            lTempAddr16 += (Word)Operand.Disp32;
                    else
                        if (Operand.DispIsNegative)
                            lTempAddr32 += Operand.Disp32;
                        else
                            lTempAddr32 += Operand.Disp32;


                if (DecodedInstruction.OverrideSegment != eGeneralRegister.NONE && DecodedInstruction.RealOpCode != 0x8d)
                    OpAdd = mProc.GetDWordRegValueForRegEnum(DecodedInstruction.OverrideSegment);
                //if (mProc.OperatingMode != ProcessorMode.Protected)
                if (mProc.mCurrInstructOpMode == ProcessorMode.Protected && mProc.regs.CS.DescriptorNum > 0)
                { }
                else
                    OpAdd = OpAdd << 4;
                if (lAddrSize16)
                    OpAdd += lTempAddr16;
                else
                    OpAdd += lTempAddr32;

                //The instructions LEA, LDS, LES, LSS don't use the value at the memory location, but rather the memory location itself, as their value
                //We only care about this in debug mode as we'll see the value for the operand, so skip this logic if not debugging
                switch (DecodedInstruction.RealOpCode)
                {
                    case 0x8d: Val.OpDWord = OpAdd; break;
                    default:
                        if ((mProc.regs.CR0 & 0x80000000) == 0x80000000 && mProc.mem.PageAccessWillCausePF(mProc, ref DecodedInstruction, OpAdd, false))
                        {
                            return;
                        }
                        else
                            switch (OcOT)
                            {
                                case sOpCodeOperandType.Byte: Val.OpByte = mProc.mem.GetByte(mProc, ref DecodedInstruction, OpAdd); OpTypeCode = TypeCode.Byte; break;
                                case sOpCodeOperandType.Word: Val.OpWord = mProc.mem.GetWord(mProc, ref DecodedInstruction, OpAdd); OpTypeCode = TypeCode.UInt16; break;
                                case sOpCodeOperandType.DWord: Val.OpDWord = mProc.mem.GetDWord(mProc, ref DecodedInstruction, OpAdd); OpTypeCode = TypeCode.UInt32; break;
                                case sOpCodeOperandType.QWord: Val.OpQWord = mProc.mem.GetQWord(mProc, ref DecodedInstruction, OpAdd); OpTypeCode = TypeCode.UInt64; break;
                                case sOpCodeOperandType.Pointer:
                                case sOpCodeOperandType.PseudoDesc:
                                    Val.OpQWord = mProc.mem.GetQWord(mProc, ref DecodedInstruction, OpAdd) & 0xFFFFFFFFFFFF; OpTypeCode = TypeCode.UInt64; break;
                            }
                        break;
                }

                return;
            #endregion
            }
            throw new Exception("ResolveOp: If you got here, you missed something!");
        }
        protected void UpdIPForShortJump(sOpVal Offset, TypeCode OpType)
        {

            switch (OpType)
            {
                case TypeCode.Byte:
                    if ((Offset.OpByte & 0x80) == 0x80)
                    {
                        Offset.OpByte = (byte)((~Offset.OpByte) + 1);
                        mProc.regs.EIP -= Offset.OpByte;
                    }
                    else
                        mProc.regs.EIP += Offset.OpByte;
                    return;
                case TypeCode.UInt16:
                    if ((Offset.OpWord & 0x8000) == 0x8000)
                    {
                        Offset.OpWord = (Word)((~Offset.OpWord) + 1);
                        mProc.regs.EIP -= Offset.OpWord;
                    }
                    else
                        mProc.regs.EIP += Offset.OpWord;
                    return;
                case TypeCode.UInt32:
                    if ((Offset.OpDWord & 0x80000000) == 0x80000000)
                    {
                        Offset.OpDWord = (DWord)((~Offset.OpDWord) + 1);
                        mProc.regs.EIP -= Offset.OpDWord;
                    }
                    else
                        mProc.regs.EIP += Offset.OpDWord;
                    return;
                default:
                    throw new Exception("Shouldn't get here");
                    break;
            }
        }
        internal static bool UpdateForNegativeAll(ref Processor_80x86 mProc, ref sOpVal Value, TypeCode OpType)
        {
            if (OpType == TypeCode.UInt64)
                return false;

            {
                switch (OpType)
                {
                    case TypeCode.Byte:
                        if ((Value.OpByte & 0x80) == 0x80)
                        {
                            Value.OpByte = (byte)(~Value.OpByte + 1);
                            return true;
                        }
                        break;
                    case TypeCode.UInt16:
                        if ((Value.OpWord & 0x8000) == 0x8000)
                        {
                            Value.OpWord = (Word)(~Value.OpWord + 1);
                            return true;
                        }
                        break;
                    case TypeCode.UInt32:
                        if ((Value.OpDWord & 0x80000000) == 0x80000000)
                        {
                            Value.OpDWord = (DWord)(~Value.OpDWord + 1);
                            return true;
                        }
                        break;
                    default:
                        throw new Exception("D'oh!");
                        break;
                }
            }
            return false;
        }
        /*        public virtual void Impl(ref Processor_80x86 mProc) { throw new ExceptionNumber("Need instruction '" + mProc.mCurrentOperation.OpCode.Name + "'override for this signature"); }
*/
        public virtual void Impl()
        {
        }
        //Turn a reference into a value.
        internal UInt32 GetSegOverriddenAddress(Processor_80x86 mProc, UInt32 Addr)
        { 
            if ( (Addr >= Processor_80x86.REGADDRBASE) && (Addr <= Processor_80x86.REGADDRBASE + Processor_80x86.RSSOFS) || (mProc.mSegmentOverride == 0))
                return Addr;
            if (mProc.OperatingMode == ProcessorMode.Protected)
            {
                if (mProc.mSegmentOverride == Processor_80x86.RCS)
                    return mProc.GetDWordRegValueForRegEnum(eGeneralRegister.CS)  + Addr;
                else if (mProc.mSegmentOverride == Processor_80x86.RES)
                    return mProc.GetDWordRegValueForRegEnum(eGeneralRegister.ES) + Addr;
                else if (mProc.mSegmentOverride == Processor_80x86.RSS)
                    return mProc.GetDWordRegValueForRegEnum(eGeneralRegister.SS) + Addr;
                else if (mProc.mSegmentOverride == Processor_80x86.RFS)
                    return mProc.GetDWordRegValueForRegEnum(eGeneralRegister.FS) + Addr;
                else if (mProc.mSegmentOverride == Processor_80x86.RGS)
                    return mProc.GetDWordRegValueForRegEnum(eGeneralRegister.GS) + Addr;

                return mProc.GetDWordRegValueForRegEnum(eGeneralRegister.DS) + Addr;
            }
            else
            {
                if (mProc.mSegmentOverride == Processor_80x86.RDS)
                    return (mProc.regs.DS.Value << 4) + Addr;
                if (mProc.mSegmentOverride == Processor_80x86.RCS)
                    return (mProc.regs.CS.Value << 4) + Addr;
                else if (mProc.mSegmentOverride == Processor_80x86.RES)
                    return (mProc.regs.ES.Value << 4) + Addr;
                else if (mProc.mSegmentOverride == Processor_80x86.RSS)
                    return (mProc.regs.SS.Value << 4) + Addr;
                else if (mProc.mSegmentOverride == Processor_80x86.RFS)
                    return (mProc.regs.FS.Value << 4) + Addr;
                else if (mProc.mSegmentOverride == Processor_80x86.RGS)
                    return (mProc.regs.GS.Value << 4) + Addr;

                return (mProc.regs.DS.Value << 4) + Addr;
            }
            throw new Exception("D'oh");
        }
        internal void SetFlagsForSubtraction(Processor_80x86 mProc, sOpVal PreVal1, sOpVal PreVal2, sOpVal Op1Val, TypeCode Op1Type)
        {
            mProc.regs.setFlagZF(Op1Val.OpQWord);
            switch (Op1Type)
            {
                case TypeCode.Byte:
                    mProc.regs.setFlagSF(Op1Val.OpByte);
            mProc.regs.setFlagAF(PreVal1.OpByte, Op1Val.OpByte);
            mProc.regs.setFlagPF(Op1Val.OpByte);
            mProc.regs.setFlagOF_Sub(PreVal1.OpByte, PreVal2.OpByte, Op1Val.OpByte);
                    break;
                case TypeCode.UInt16:
                    mProc.regs.setFlagSF(Op1Val.OpWord);
            mProc.regs.setFlagAF(PreVal1.OpWord, Op1Val.OpWord);
            mProc.regs.setFlagPF(Op1Val.OpWord);
            mProc.regs.setFlagOF_Sub(PreVal1.OpWord, PreVal2.OpWord, Op1Val.OpWord);
                    break;
                case TypeCode.UInt32:
                    mProc.regs.setFlagSF(Op1Val.OpDWord);
            mProc.regs.setFlagAF(PreVal1.OpDWord, Op1Val.OpDWord);
            mProc.regs.setFlagPF(Op1Val.OpDWord);
            mProc.regs.setFlagOF_Sub(PreVal1.OpDWord, PreVal2.OpDWord, Op1Val.OpDWord);
                    break;
                case TypeCode.UInt64:
                    mProc.regs.setFlagSF(Op1Val.OpQWord);
            mProc.regs.setFlagAF(PreVal1.OpQWord, Op1Val.OpQWord);
            mProc.regs.setFlagPF(Op1Val.OpQWord);
            mProc.regs.setFlagOF_Sub(PreVal1.OpQWord, PreVal2.OpQWord, Op1Val.OpQWord);
                    break;
            }
        }
        internal void SetFlagsForAddition(Processor_80x86 mProc, sOpVal PreVal1, sOpVal PreVal2, sOpVal Op1ValSigned, sOpVal Op1ValUnsigned, TypeCode Op1Type)
        {
            mProc.regs.setFlagZF(Op1ValSigned.OpQWord);
            mProc.regs.setFlagAF(Op1ValSigned.OpQWord, PreVal1.OpQWord);
            //mProc.regs.setFlagCF(Op1ValUnsigned.OpQWord, PreVal1.OpQWord, PreVal2.OpQWord);
            mProc.regs.setFlagPF(Op1ValSigned.OpQWord);

            switch (Op1Type)
            {
                case TypeCode.Byte:
                    mProc.regs.setFlagOF_Add(PreVal1.OpByte, PreVal2.OpByte, Op1ValSigned.OpByte);
                    mProc.regs.setFlagSF(Op1ValSigned.OpByte);
                    break;
                case TypeCode.UInt16:
                    mProc.regs.setFlagOF_Add(PreVal1.OpWord, PreVal2.OpWord, Op1ValSigned.OpWord);
                    mProc.regs.setFlagSF(Op1ValSigned.OpWord);
                    break;
                case TypeCode.UInt32:
                    mProc.regs.setFlagOF_Add(PreVal1.OpDWord, PreVal2.OpDWord, Op1ValSigned.OpDWord);
                    mProc.regs.setFlagSF(Op1ValSigned.OpDWord);
                    break;
                case TypeCode.UInt64:
                    mProc.regs.setFlagOF_Add(PreVal1.OpQWord, PreVal2.OpQWord, Op1ValSigned.OpQWord);
                    mProc.regs.setFlagSF(Op1ValSigned.OpQWord);
                    break;
            }


        }

        public Instruct CopyOf()
        {
            //Instruct wise;
            //wise = (Instruct)MemberwiseClone();
            //Instruct il;
            //il = (Instruct)Misc.CloneObjectWithIL(this);
            //return (Instruct)MemberwiseClone();
            return (Instruct)Misc.CloneObjectWithIL(this);
        }

        internal static bool VerifyCPL0(Processor_80x86 mProc, ref sInstruction mIns )
        {
            if (mProc.regs.CPL != 0)
            {
                mIns.ExceptionNumber = 0xD;
                mIns.ExceptionThrown = true;
                mIns.ExceptionErrorCode = 0;
                mIns.ExceptionAddress = mIns.InstructionAddress;

                if (mProc.mSystem.Debuggies.DebugCPU || mProc.mSystem.Debuggies.DebugExceptions)
                    mProc.mSystem.PrintDebugMsg(eDebuggieNames.Exceptions, mProc.mCurrentInstruction.Name + " executed @ CPL of " + mProc.regs.CPL + ".  Exception 13 triggered");
                return false;
            }
            return true;
        }
        internal static void SetLoopComplete(Processor_80x86 mProc)
        {
            mProc.mRepeatCondition = Processor_80x86.NOT_REPEAT;
        }
    }
}
